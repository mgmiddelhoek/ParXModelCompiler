//
// PXModelInterpreter.m
// ParXModelCompiler
//
// Copyright (c) 2015-2025 Martin G. Middelhoek <martin@middelhoek.com>.
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.
//

#import <Foundation/Foundation.h>
#import "PXModelInterpreter.h"
#import "PXModelCode.h"

@interface PXModelInterpreter ()

- (BOOL)referenceCode:(PXModelCode *)modelCode;

@end

/**
 @brief Interpreter for model code generated by the ParX Model Compiler
 */
@implementation PXModelInterpreter {

    /** number of residuals */
    int nRes;

    /** number of variables */
    int nVar;

    /** number of auxillary variables */
    int nAux;

    /** number of parameters */
    int nPar;

    /** number of flags */
    int nFlg;

    /** number of constants */
    int nCon;

    /** number of numerical constants */
    int nNum;

    /** number of temporaries */
    int nTmp;

    /** length of code stack */
    int nCode;

    /** Start pointer for kinds of deriv.s
     *
     * [0]: function code <br>
     * [1]: variables derivatives <br>
     * [2]: auxiliaries derivatives <br>
     * [3]: parameters derivatives <br>
     */
    CODE *kindStart[4];

    /** operand stack */
    double *Stack;

    /** pointer to temporaries store */
    double *Tmp;

    /** pointer to deriv. of temporaries */
    double *DTmp;

    /** pointer to numerical constants */
    double *Num;
}

/**
 @brief Initialize with compiled model code

 @param modelCode compiled code
 */
- (PXModelInterpreter *)initWithCode:(PXModelCode *)modelCode {

    self = [super init];
    if (self) {
        nRes = (int)[[modelCode resName] count];
        nVar = (int)[[modelCode varName] count];
        nAux = (int)[[modelCode auxName] count];
        nPar = (int)[[modelCode parName] count];
        nFlg = (int)[[modelCode flgName] count];
        nCon = (int)[[modelCode conName] count];
        nNum = [modelCode getLengthNumbers];
        nTmp = [modelCode numberOfTemp];
        nCode = [modelCode getLengthCode];

        if (nNum < 0 || nTmp < 0) {
            return nil;
        }
        if (nTmp > 0) {
            Tmp = (double *)calloc(nTmp, sizeof(double));
            DTmp = (double *)calloc(nTmp, sizeof(double));
        } else {
            Tmp = NULL;
            DTmp = NULL;
        }

        if (nNum > 0) {
            Num = (double *)calloc(nNum, sizeof(double));
            double *inNum = [modelCode getModelNumbers];
            for (int i = 0; i < nNum; i++) {
                Num[i] = inNum[i];
            }
        } else {
            Num = NULL;
        }

        int maxCodeSize = nCode * 2; /* always ok. Worst case: all codes
                                        if/else, or all push on stack */

        kindStart[0] = (CODE *)calloc(maxCodeSize, sizeof(CODE));
        kindStart[1] = NULL;
        kindStart[2] = NULL;
        kindStart[3] = NULL;

        Stack = (double *)calloc(maxCodeSize, sizeof(double));

        _errorCode = 0;

        int result = [self referenceCode:modelCode];
        if (!result) {
            return nil;
        }
    }
    return self;
}

- (void)dealloc {

    free(Tmp);
    free(DTmp);
    free(Num);
    free(kindStart[0]);
    free(Stack);
}

/**
 @brief Input and adaptation of interpreter code

 @discussion    check array indices <br>
 replace for conditionals indices by pointers

 @param modelCode model code
 @return YES/NO for success
 */
- (BOOL)referenceCode:(PXModelCode *)modelCode {

    OPR opr = INVAL; /* current operator */
    TYP typ;         /* type of operand */
    int ind;         /* index of operand */
    int kod = 0;     /* kind of derivatives (var, aux or par) */

    CODE *IfPos[MAXLEVEL + 1] = {NULL};
    CODE *ElsePos[MAXLEVEL + 1] = {NULL};
    int level = 0;

    CODE *inCode = [modelCode getModelCode];
    CODE *code = kindStart[0];

    for (int i = 0; i < nCode; i++) {
        opr = inCode[i].o;
        if (opr >= STOP) {
            break;
        }
        switch (opr) {
        default:
            (*code++).o = opr;
            break;
        case DOPD:
        case OPD:
        case ASS:
        case NASS:
        case CLR:
            typ = inCode[++i].t;
            ind = inCode[++i].i;
            switch (typ) { /* check array index */
            case VAR:
                if (ind >= nVar) {
                    return NO;
                }
                break;
            case AUX:
                if (ind >= nAux) {
                    return NO;
                }
                break;
            case PAR:
                if (ind >= nPar) {
                    return NO;
                }
                break;
            case CON:
                if (ind >= nCon) {
                    return NO;
                }
                break;
            case FLG:
                if (ind >= nFlg) {
                    return NO;
                }
                break;
            case RES:
                if (ind >= nRes) {
                    return NO;
                }
                break;
            case TMP:
                if (ind >= nTmp) {
                    return NO;
                }
                break;
            case DRES:
                if (ind >= nRes) {
                    return NO;
                }
                break;
            case DTMP:
                if (ind >= nTmp) {
                    return NO;
                }
                break;
            default:
                return NO;
                break;
            }
            (*code++).o = opr;
            (*code++).t = typ;
            (*code++).i = ind;
            break;
        case NUM:
            ind = inCode[++i].i;
            (*code++).o = opr;
            (*code++).i = ind;
            break;
        case IF:
            (*code++).o = IF;
            IfPos[++level] = code++;
            ElsePos[level] = (CODE *)NULL;
            break;
        case ELSE:
            (*code++).o = JMP;
            ElsePos[level] = code++;
            assert(IfPos[level] != NULL);
            (*IfPos[level]).c = code;
            break;
        case FI:
            if (ElsePos[level]) {
                (*ElsePos[level]).c = code;
            } else {
                assert(IfPos[level] != NULL);
                (*IfPos[level]).c = code;
            }
            level--;
            break;
        case EOD: /* End Of (single) Derivative */
            (*code++).o = EOD;
            break;
        case SOK: /* Start Of Kind of derivatives */
            kindStart[++kod] = code;
            (*code++).o = SOK;
            break;
        }
    }

    if (opr != STOP) {
        return NO;
    }
    (*code).o = INVAL;

    return YES;
}

/**
 @brief Execution of interpreter code

 @param x variables
 @param a auxillary variables
 @param p parameters
 @param c constants
 @param f flags
 @param r residuals
 @param jxf flag evaluate Jacobian for variables
 @param xf flags per variable
 @param jx Jacobian for variables
 @param ja Jacobian for auxillary variables
 @param jpf flag evaluate Jacobian for parameters
 @param pf flags per parameter
 @param jp Jacobian for parameters
 @return YES/NO for success
 */
- (BOOL)evaluateForVar:(const double *)x
                   aux:(const double *)a
                   par:(const double *)p
                   con:(const double *)c
                  flag:(const double *)f
                   res:(double *)r
              jacXFlag:(const BOOL)jxf
              varFlags:(const BOOL *)xf
                  JacX:(double *)jx
                  JacA:(double *)ja
              jacPFlag:(const BOOL)jpf
              parFlags:(const BOOL *)pf
                  JacP:(double *)jp {
    /** interpreter code pointer */
    CODE *code = kindStart[0];

    /** operand stack pointer */
    double *pSt = Stack;

    int kod = 0;      /* kind of derivatives              */
    int iDvt = 0;     /* index of current deriv. variable */
    double *jac = jx; /* pointer to current Jacobian      */

    OPR opr;    /* operator                         */
    TYP typ;    /* type of operand                  */
    int ind;    /* operand index                    */
    double val; /* operand value                    */

    self.errorCode = 0;

    for (;;) {
        opr = (*code++).o;
        switch (opr) {
        default:
            self.errorCode = -1;
            return NO; /* error */
        case INVAL:
            return YES; /* finished */
        case AND:
            pSt--;
            *pSt = (*pSt != 0 && *(pSt + 1) != 0) ? 1 : 0;
            break;
        case OR:
            pSt--;
            *pSt = (*pSt != 0 || *(pSt + 1) != 0) ? 1 : 0;
            break;
        case NOT:
            *pSt = (*pSt == 0) ? 1 : 0;
            break;
        case LT:
            pSt--;
            *pSt = (*pSt < *(pSt + 1)) ? 1 : 0;
            break;
        case GT:
            pSt--;
            *pSt = (*pSt > *(pSt + 1)) ? 1 : 0;
            break;
        case LE:
            pSt--;
            *pSt = (*pSt <= *(pSt + 1)) ? 1 : 0;
            break;
        case GE:
            pSt--;
            *pSt = (*pSt >= *(pSt + 1)) ? 1 : 0;
            break;
        case EQ:
            pSt--;
            *pSt = (*pSt == *(pSt + 1)) ? 1 : 0;
            break;
        case NE:
            pSt--;
            *pSt = (*pSt != *(pSt + 1)) ? 1 : 0;
            break;
        case ADD:
            pSt--;
            *pSt = *pSt + *(pSt + 1);
            break;
        case SUB:
            pSt--;
            *pSt = *pSt - *(pSt + 1);
            break;
        case MUL:
            pSt--;
            *pSt = *pSt * *(pSt + 1);
            break;
        case DIV:
            pSt--;
            *pSt = *pSt / *(pSt + 1);
            break;
        case POW:
            pSt--;
            *pSt = pow(*pSt, *(pSt + 1));
            break;
        case SGN:
            *pSt = (*pSt >= 0) ? 1 : -1;
            break;
        case SIN:
            *pSt = sin(*pSt);
            break;
        case COS:
            *pSt = cos(*pSt);
            break;
        case TAN:
            *pSt = tan(*pSt);
            break;
        case ASIN:
            *pSt = asin(*pSt);
            break;
        case ACOS:
            *pSt = acos(*pSt);
            break;
        case ATAN:
            *pSt = atan(*pSt);
            break;
        case SINH:
            *pSt = sinh(*pSt);
            break;
        case COSH:
            *pSt = cosh(*pSt);
            break;
        case TANH:
            *pSt = tanh(*pSt);
            break;
        case ERF:
            *pSt = erf(*pSt);
            break;
        case EXP:
            *pSt = exp(*pSt);
            break;
        case LOG:
            *pSt = log(*pSt);
            break;
        case LG:
            *pSt = log10(*pSt);
            break;
        case SQRT:
            *pSt = sqrt(*pSt);
            break;
        case SQR:
            *pSt = *pSt * *pSt;
            break;
        case NEG:
            *pSt = -*pSt;
            break;
        case REV:
            *pSt = 1.0 / *pSt;
            break;
        case INC:
            *pSt += 1;
            break;
        case DEC:
            *pSt -= 1;
            break;
        case ABS:
            if (*pSt < 0) {
                *pSt = -*pSt;
            }
            break;
        case RET:
            self.errorCode = *pSt;
            // return (*pSt == 0) ? YES : NO;
            return NO;
            break;
        case CHKL:
            pSt--;
            if (*pSt < *(pSt + 1)) {
                return NO;
            }
            pSt--;
            break;
        case CHKG:
            pSt--;
            if (*pSt > *(pSt + 1)) {
                return NO;
            }
            pSt--;
            break;
        case DOPD:
        case OPD:
            typ = (*code++).t;
            ind = (*code++).i;

            switch (typ) {
            case VAR:
                val = x[ind];
                break;
            case AUX:
                val = a[ind];
                break;
            case PAR:
                val = p[ind];
                break;
            case CON:
                val = c[ind];
                break;
            case FLG:
                val = f[ind] > 0.5 ? 1 : 0;
                break;
            case RES:
                val = r[ind];
                break;
            case TMP:
                val = Tmp[ind];
                break;
            case DRES:
                val = jac[iDvt * nRes + ind];
                break;
            case DTMP:
                val = DTmp[ind];
                break;
            default:
                self.errorCode = -1;
                return NO;
                break;
            }
            *(++pSt) = val;
            break;
        case NUM:
            ind = (*code++).i;
            *(++pSt) = Num[ind];
            break;
        case LDF:
            ind = (*code++).i;
            *(++pSt) = f[ind] > 0.5 ? 1 : 0;
            break;
        case ASS:
        case NASS:
        case CLR:
            typ = (*code++).t;
            ind = (*code++).i;
            if (opr == ASS) {
                val = *(pSt--);
            } else if (opr == NASS) {
                val = -(*(pSt--));
            } else {
                val = 0.0;
            }
            switch (typ) {

            case RES:
                r[ind] = val;
                break;
            case TMP:
                Tmp[ind] = val;
                break;
            case DRES:
                jac[iDvt * nRes + ind] = val;
                break;
            case DTMP:
                DTmp[ind] = val;
                break;
            default:
                self.errorCode = -1;
                return NO;
                break;
            }
            break;
        case IF:
            if (*(pSt--) == 0) {
                code = (*code).c;
            } else {
                code++;
            }
            break;
        case EOD:
            iDvt++;
            if ((kod == 1) && (iDvt < nVar) && (xf[iDvt] == NO)) {
                for (code++; (*code).o != EOD; code++)
                    ; /* skip over variable derivative */
            }
            if ((kod == 3) && (iDvt < nPar) && (pf[iDvt] == NO)) {
                for (code++; (*code).o != EOD; code++)
                    ; /* skip over parameter derivative */
            }
            break;
        case SOK:
            kod++;
            iDvt = 0;
            jac = (kod == 1) ? jx : (kod == 2) ? ja : jp;
            if (kod == 1) {
                if (jxf == NO) {
                    code = kindStart[3]; /* skip straight to parameter
                                            derivatives */
                    kod++;
                } else if (xf[iDvt] == NO) {
                    for (code++; (*code).o != EOD; code++)
                        ; /* skip over first variable derivative */
                }
            } else if (kod == 3) {
                if (jpf == NO) {
                    return YES;
                }
                if (pf[iDvt] == NO) {
                    for (code++; (*code).o != EOD; code++)
                        ; /* skip over first parameter derivative */
                }
            }
            break;
        case JMP:
            code = (*code).c;
            break;
        }
    }
    return YES;
}

@end
